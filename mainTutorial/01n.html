<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SadTutorial Core 01n - Networking</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../simple.css">
</head>
<body>
    <h1>0. Chapter Goals</h1>
    <p>"Networking?!" you may ask? Networking! There's not that many tutorials out there on how to handle networking in a relatively simple way for games. The library we'll be using is message-based and asynchronous, which is how Valve's Steamworks API works as well, so a lot of these concept should translate if you are making a game for release on Steam. The pattern we're going for results in a game where the client program can host a server freely, allowing others to connect. This is a little inconvenient if you want a more MMO style thing, but with a little elbow grease it should work for a decent number of simultaneous players. </p>
 
    <h1>1. Telepathy</h1>
    <p>No, not the superpower, it's the networking library we'll be using. Grab the Telepathy.dll from the resources folder of this tutorial, where you were hopefully able to also get the fonts.zip, and put it in the root of your project. On the right sidebar right click Dependencies and add a project dependency, then navigate to your project folder and select Telepathy.dll. This should properly link up things so that you can reference it via code, which we'll be doing extensively in <b>NetworkManager.cs</b> in a moment. </p>

    <h1>2a. Preparations - UI_GameArea</h1>
    <p> Before we get to that, go to <b>UI_GameArea</b> and add two new variables: <b>public List<string> MessageLog = new();</b> and <b>public bool NetSwitch = false;</b>, then add the following code at the bottom of the Update method.</p>

    <div class="code_block">
    Con.PrintClickable(0, 11, "Network Switch: " + NetSwitch.ToString(), () => {
        NetSwitch = !NetSwitch;
        NetMsg msg = new("SetBool", -1);
        msg.MiscBool = NetSwitch;

        GameSettings.SendMessageIfNecessary(msg, -1);
    }); 

    if (!GameSettings.NetworkManager.IsServerRunning() && !GameSettings.NetworkManager.IsClientConnected()) {
        Con.PrintClickable(50, 0, "Start Server", () => { GameSettings.NetworkManager.StartServer(); });
         
        Con.PrintClickable(65, 0, "Join Local Server", () => { GameSettings.NetworkManager.JoinServer("localhost", 25565); });
    }

    for (int i = 0; i < 20 && i < MessageLog.Count; i++) {
        Con.Print(50, i, MessageLog[i]);
    }
    </div>   

    <p> These are fairly simple tools for connecting and testing the connection. The first PrintClickable "line" toggles our new switch, then constructs a message with a new type we'll be making and sends it with a method we'll get to it in a moment. The next two PrintClickables are only shown if there's no connection or server already, and the for-loop simply displays the first 20 messages held in our log.</p>


    <h1>2b. Preparations - GameSettings</h1>
    <p> Next let's move to <b>GameSettings.cs</b> for some moderate changes. Add a new variable, <b>public static NetworkManager NetworkManager;</b>. Over in <b>Program.cs</b> real quick add <b>GameSettings.NetworkManager = new NetworkManager();</b> underneath the UIManager creation and in our empty Update function add <b>GameSettings.NetworkManager.Update();</b>, then back in <b>GameSettings.cs</b> the final change to this file is adding the following functions.

    <div class="code_block">
    private static void Update(object sender, GameHost e) {
        NetworkManager.Update();
    }

    public static void SendMessageIfNecessary(NetMsg msg, int recipient) {
        if (NetworkManager.IsServerRunning()) {
            msg.SenderID = -1;
            NetworkManager.ServerSend(msg, recipient);
        }

        if (NetworkManager.IsClientConnected()) {
            NetworkManager.ClientSend(msg);
        }
    }
    </div> 
    <p> Our additions to <b>Program.cs</b> will initialize the Network Manager and call its update every frame, while <b>SendMessageIfNecessary</b> will handle routing our network messages to the server or clients as necessary.</p>
 
    <h1>2c. Preparations - NetMsg</h1>
    <p> Create a folder in your project root called Data, then a file inside it called <b>NetMsg.cs</b> with the following code:
    <div class="code_block">
    namespace SadTutorial.Data {
        public class NetMsg {
            public int SenderID = -1;
            public string Message = "";

            public int MiscInt = 0;
            public bool MiscBool = false;
            public string MiscString = "";


            public NetMsg(string msg, int ownID) {
                Message = msg;
                SenderID = ownID;
            }
        }
    } 
    </div>
    <p> This simple structure is the backbone of our networking code. The main two fields used for every message we exchange between server and client are SenderID and Message. Message in particular is the most important, as it'll be what we read first to determine what action needs to be taken when the message is received. MiscInt, MiscBool, and MiscString are extra fields for sending along data we might need in specific circumstances.

    <h1>3. The Beast - NetworkManager</h1>
    <p>We can put it off no longer, and all that remains for us to hook everything together into a working client-server system falls in our last file. Because this one is a little lengthier than files we've done up to this point, we'll take it in small easily understood chunks. To start, create a file in your project root called <b>NetworkManager.cs</b> and add the following code: </p>

    <div class="code_block">
    using SadTutorial.Data;
    using System; 
    using Telepathy; 

    namespace SadTutorial {
        public class NetworkManager {
            Server server;
            Client client;

            public NetworkManager() {
                server = new Server(4096);
                server.OnConnected = OnConnected;
                server.OnData = OnData;
                server.OnDisconnected = OnDisconnected;


                client = new Client(4096);
                client.OnConnected = () => {
                    GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Connected to server.");
                };

                client.OnDisconnected = () => {
                    GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Disconnected from server.");
                };

                client.OnData = ClientOnData;
            }
        }
    }
    </div>
    <p> Nothing too fancy so far. We create the server and client variables, initialize them with a max message size of 4096 bytes, and add a function call to each of the events we need to handle. For the client they just need a confirmation of their actions, so we use a simple lambda in each with a call to log the message back in UI_GameArea. All of the 13 functions we'll be adding will be provided, then explained in the block following it. All of them are to be placed in the NetworkManager class beside the constructor, in any order you choose.</p>
    
    <hr>
    <div class="code_block">
    public void Update() {
        if (server != null && server.Active) {
            server.Tick(100);
        }

        if (client != null && client.Connected) {
            client.Tick(100);
        }
    }
    </div>
    <p> Like all of our 13 functions, this first one is important but short. Whenever the Update function is called, and as you may recall we set it up to be called every frame, Tick the Server (if hosting) or the Client (if connected) to receive new messages, if any exist.</p>
    
    <hr>
    <div class="code_block">
    public void ServerSend(NetMsg msg, int toId = -1) {
        if (toId == -1) { 
            server.Broadcast(msg.ToByteArray());
        } else {
            server.Send(toId, msg.ToByteArray());
        }
    }
    </div>
    <p>This is the function we use on the Server to send messages out. If the recipient ID is -1, we'll broadcast to all connected clients. Otherwise we'll send the message just to the specific client. Notice that the data sent must be in the format of a byte array, which is why we made sure to add our new Helper functions to convert any object into bytes and back at will.</p>

    <hr>
    <div class="code_block">
    public void ClientSend(NetMsg msg) {
        client.Send(msg.ToByteArray());
    }
    </div>
    <p>This one is even simpler, and handles sending messages as the client. We only ever need the client to talk to the server directly, so we just accept a NetMsg and convert it to bytes before blasting it out in the direction of the server.</p>

    <hr>
    <div class="code_block">
    public void JoinServer(string IP, int port) {
        client.Connect(IP, port);
    }
    </div>
    <p>Another simple but powerful function. We take a passed in IP and Port, and tell the client to try to form a connection at the address. Connect doesn't return any types so we can't directly check to see if it failed, but we'll leave it without failure checks for now and just assume it worked.</p>

    <hr>
    <div class="code_block">
    public void StartServer() {
        server.Start(25565);
        GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Server started on port 25565.");
    }
    </div>
    <p>Here we have the function for starting up a server, currently set to open it on port 25565. Feel free to change this if you like, just remember to change the JoinServer call accordingly. We also log a message to let the player know that the server has been started, and on what port. With a little effort you could allow hosts to set their own port, and let clients specify what port they want to connect on. For now that's outside the scope of the tutorial, so we'll move on.</p>

    <hr>
    <div class="code_block">
    public void StopServer() {
        server.Stop();
        GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Server stopped.");
    }
    </div>
    <p>The opposite of the previous function, disconnects all clients and closes the server listener. Again we log the outcome to keep the host informed.</p>

    <hr>
    <div class="code_block">
    public bool IsServerRunning() {
        if (server != null)
            return server.Active;
        return false;
    }
    </div>
    <p>Simply lets other files check if the server is running without being able to access the server variable itself.</p>

    <hr>
    <div class="code_block">
    public bool IsClientConnected() {
        if (client != null)
            return client.Connected;
        return false;
    }
    </div>
    <p>Similarly we have a function to see if the client is connected. Ideally we never end up with a server hosted and a client connected at the same time, though I think theoretically it could be possible.</p>

    <hr>
    <div class="code_block">
    public void OnConnected(int connectionId, string test) {
        GameSettings.UIManager.GameArea.MessageLog.Insert(0, connectionId + " connected.");
    }
    </div>
    <p>This function is what we plugged into the Server.OnConnected event in the constructor, and for now all it does it log that a client has connected.</p>

    <hr>
    <div class="code_block">
    public void OnDisconnected(int connectionId) { 
        GameSettings.UIManager.GameArea.MessageLog.Insert(0, connectionId + " disconnected.");
    }
    </div>
    <p>And the opposite side of the coin, our Server.OnDisconnected event, which is run whenever a client disconnects and logs that they did so.</p>

    <hr>
    <div class="code_block">
    public void ClientOnData(ArraySegment<byte> data) {
        OnData(-1, data);
    }
    </div>
    <p>This is a bit of a prelude to the core of our networking code, which is next. All it does it pass along the data the client gets and runs our general processing code while assuming it's from the server (as it must be, the way things are set up).</p>

    <hr>
    <div class="code_block">
    public void DisconnectFromServer() {
        client.Disconnect();
    }
    </div>
    <p>This is just a very simple function we can call to make the client disconnect from the server they're currently connected to.</p>
    
    <hr>
    <div class="code_block">
    public void OnData(int connectionId, ArraySegment<byte> data) {
        NetMsg msg = data.Array.FromByteArray<NetMsg>();

        if (msg.Message == "SetBool") {
            GameSettings.UIManager.GameArea.NetSwitch = msg.MiscBool;
            GameSettings.UIManager.GameArea.MessageLog.Insert(0, connectionId + " set the switch to " + msg.MiscBool.ToString() + ".");
        }
    }
    </div>
    <p>At last we get to the real meat of the file! Here we receive the byte array in the message and convert it back into a NetMsg object for reading, then we can operate on it accordingly. For now our only message sending line, back in UI_GameArea, sets the Message identifier to 'SetBool', so we know that the incoming message is interfacing with our shiny new network switch. We set the switch to match MiscBool, then log that the bool was set by the person with the matching connectionId. This is where you'll expand to create the handling for anything and everything that needs to be synced in multiplayer. Simply remember to match the message identifiers and it should be easy enough to handle.</p>

    <h1>4. Conclusion</h1>
    <p> If you've followed all the steps, and I didn't forget anything, then you should now be able to open up two copies of the program and have them connect to eachother! Just click host on one (which should be verified by saying the server started), click join on the other (which should be verified locally by saying it connected and on the server saying someone connected), and then try clicking on the Network Switch on either window. If everything worked, you should see the switch changing to match on both windows, plus a message whenever the other person toggles the switch.</p>

    <p>Assuming you made it this far and everything is working, you've now got a decent base to build up a multiplayer game with! You can easily expand NetMsg to send additional types of data along (anything that can be serialized and deserialized), and you can use our message identifier system to act on messages as they come in. Future tutorial chapters will assume that you did <em>not</em> do all this, but supplementary chapters will be included alongside each one to show the changes necessary to make everything work in multiplayer as well.</p>
    
    <button type="button" class="collapsible"><b>Complete</b> Program.cs</button>
    <div class="hidden_block">
    using SadConsole.Configuration;
    using SadTutorial.UI;
    using SadTutorial;

    Settings.WindowTitle = "SadTutorial";

    Builder startup = new Builder()
        .SetScreenSize(GameSettings.GameWidth, GameSettings.GameHeight)
        .SetStartingScreen((host) => {
            GameSettings.SquareFont = Game.Instance.Fonts["CheepicusExtended"];
            GameSettings.UIManager = new UIManager();
            GameSettings.NetworkManager = new NetworkManager();

            GameSettings.UIManager.Init();

            return GameSettings.UIManager;
        })
        .IsStartingScreenFocused(true)
        .ConfigureFonts("./fonts/ThinExtended.font", new[] { "./fonts/CheepicusExtended.font" })
        .AddFrameUpdateEvent(GameHost_FrameUpdate)
        ;

    Game.Create(startup);
    Game.Instance.Run();
    Game.Instance.Dispose();

    static void GameHost_FrameUpdate(object sender, GameHost e) {
        GameSettings.NetworkManager.Update();
    }
    </div>

    <button type="button" class="collapsible"><b>Complete</b> GameSettings.cs</button>
    <div class="hidden_block">
    using SadTutorial.Data;
    using SadTutorial.UI;

    namespace SadTutorial {
        public static class GameSettings {
            public const int GameWidth = 160;
            public const int GameHeight = 50;

            public static IFont SquareFont;

            public static UIManager UIManager;
            public static NetworkManager NetworkManager;

            public static void SendMessageIfNecessary(NetMsg msg, int recipient) {
                if (NetworkManager.IsServerRunning()) {
                    msg.SenderID = -1;
                    NetworkManager.ServerSend(msg, recipient);
                }

                if (NetworkManager.IsClientConnected()) {
                    NetworkManager.ClientSend(msg);
                }
            }
        }
    }
    </div>

    <button type="button" class="collapsible"><b>Complete</b> UI_GameArea.cs</button>
    <div class="hidden_block">
    using SadAdditions; 
    using SadConsole.Input;
    using SadTutorial.Data;

    namespace SadTutorial.UI {
        public class UI_GameArea : InstantUI {
            int counter = 0;
            bool switch1 = false;
            bool switch2 = false;
            bool clickSwitch = false;
            public bool NetSwitch = false;

            public List<string> MessageLog = new();

            public UI_GameArea(int width, int height) : base(width, height, "") {
                Win.IsVisible = true;
                Win.Position = new Point(0, 0);
                Win.CanDrag = false;
            }

            public override void Update() {
                Win.Clear();
                Extensions.DrawBox(Win, 0, 0, Win.Width - 2, Win.Height - 2);

                Con.Clear();
                SquareCon.Clear();
                DoubleSquareCon.Clear();

                Con.Print(0, 0, "Hello World!");
                SquareCon.Print(0, 1, "Hello World!");
                DoubleSquareCon.Print(0, 1, "Hello World!");

                if (Shorthands.KeyPressed(Keys.Space)) {
                    switch1 = !switch1;
                }

                if (Miscellania.HotkeyDown(Keys.Space)) {
                    switch2 = !switch2;
                }

                Con.Print(0, 5, "Switch 1 (Spacebar): " + switch1.ToString());
                Con.Print(0, 6, "Switch 2 (Space hotkey): " + switch2.ToString()); 
                Con.PrintClickable(0, 8, "Lambda Click: " + clickSwitch.ToString() + " [" + counter + " clicks]", () => {
                    clickSwitch = !clickSwitch;
                    counter++;
                });

                Con.PrintClickable(0, 9, "Non-lambda Click: " + clickSwitch.ToString() + " [" + counter + " clicks]", ButtonClick);

                Con.PrintClickable(0, 11, "Network Switch: " + NetSwitch.ToString(), () => {
                    NetSwitch = !NetSwitch;
                    NetMsg msg = new("SetBool", -1);
                    msg.MiscBool = NetSwitch;

                    GameSettings.SendMessageIfNecessary(msg, -1);
                });

                if (!GameSettings.NetworkManager.IsServerRunning() && !GameSettings.NetworkManager.IsClientConnected()) {
                    Con.PrintClickable(50, 0, "Start Server", () => { GameSettings.NetworkManager.StartServer(); });

                    Con.PrintClickable(65, 0, "Join Local Server", () => { GameSettings.NetworkManager.JoinServer("localhost", 25565); });
                }

                for (int i = 0; i < 20 && i < MessageLog.Count; i++) {
                    Con.Print(50, i, MessageLog[i]);
                }
            }

            public override void Input() {

            } 

            public void ButtonClick() {
                clickSwitch = !clickSwitch;
                counter++;
            }
        }
    } 
    </div> 

    <button type="button" class="collapsible"><b>Complete</b> NetMsg.cs</button>
    <div class="hidden_block">
    namespace SadTutorial.Data {
        public class NetMsg {
            public int SenderID = -1;
            public string Message = "";

            public int MiscInt = 0;
            public bool MiscBool = false;
            public string MiscString = "";


            public NetMsg(string msg, int ownID) {
                Message = msg;
                SenderID = ownID;
            }
        }
    }
    </div>

    <button type="button" class="collapsible"><b>Complete</b> NetworkManager.cs</button>
    <div class="hidden_block">
    using SadAdditions;
    using SadTutorial.Data;
    using System;
    using Telepathy;

    namespace SadTutorial {
        public class NetworkManager {
            Server server;
            Client client;

            public NetworkManager() {
                server = new Server(4096);
                server.OnConnected = OnConnected;
                server.OnData = OnData;
                server.OnDisconnected = OnDisconnected;


                client = new Client(4096);
                client.OnConnected = () => {
                    GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Connected to server.");
                };

                client.OnDisconnected = () => {
                    GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Disconnected from server.");
                };

                client.OnData = ClientOnData;
            }

            // BOTH: Call the Tick function to send and receive any waiting messages, whether hosting or connecting.
            public void Update() {
                if (server != null && server.Active) {
                    server.Tick(100);
                }

                if (client != null && client.Connected) {
                    client.Tick(100);
                }
            }

            // SERVER: Either broadcast a message to all clients or send a message to a specific client as requested.
            public void ServerSend(NetMsg msg, int toId = -1) {
                if (toId == -1) {
                    server.Broadcast(msg.ToByteArray());
                }
                else {
                    server.Send(toId, msg.ToByteArray());
                }
            }

            // CLIENT: Send a message to the server host
            public void ClientSend(NetMsg msg) {
                client.Send(msg.ToByteArray());
            }



            // CLIENT: Try to connect to a server at the given IP and Port (requires the server to Port Forward in most cases)
            public void JoinServer(string IP, int port) {
                client.Connect(IP, port);
            }

            // SERVER: Start the server listener
            public void StartServer() {
                server.Start(25565);
                GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Server started.");
            }

            // SERVER: Disconnect all clients and stop the server.
            public void StopServer() {
                server.Stop();
                GameSettings.UIManager.GameArea.MessageLog.Insert(0, "Server stopped.");
            }

            // SERVER: Returns true if hosting a server currently
            public bool IsServerRunning() {
                if (server != null)
                    return server.Active;
                return false;
            }

            // CLIENT: Returns true if acting as a client and connected to a server.
            public bool IsClientConnected() {
                if (client != null)
                    return client.Connected;
                return false;
            }

            // SERVER: What to do when a client connects, for now simply log it.
            public void OnConnected(int connectionId, string test) {
                GameSettings.UIManager.GameArea.MessageLog.Insert(0, connectionId + " connected.");
            }

            // SERVER: What to do when a client disconnects, for now simply log it.
            public void OnDisconnected(int connectionId) {
                GameSettings.UIManager.GameArea.MessageLog.Insert(0, connectionId + " disconnected.");
            }

            // CLIENT: Receive the data, pass it to the main processor with our special ID for the server (-1)
            public void ClientOnData(ArraySegment<byte> data) {
                OnData(-1, data);
            }


            // BOTH: Process a message into something actionable
            public void OnData(int connectionId, ArraySegment<byte> data) {
                NetMsg msg = data.Array.FromByteArray<NetMsg>();

                if (msg.Message == "SetBool") {
                    GameSettings.UIManager.GameArea.NetSwitch = msg.MiscBool;
                    GameSettings.UIManager.GameArea.MessageLog.Insert(0, connectionId + " set the switch to " + msg.MiscBool.ToString() + ".");
                }
            }

            // CLIENT: Disconnect from Server
            public void DisconnectFromServer() {
                client.Disconnect();
            }
        }
    }
    </div>

    <p>
    <a href="./02.html">Chapter 02: TBD</a>
    <br>
    <a href="../index.html">Back to Index</a></p>
    <script src="../javascript.js"></script>
</body>
</html>