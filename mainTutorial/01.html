<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SadTutorial Core 01 - Some Foundational Work</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../simple.css">
</head>
<body>
    <h1>0. Semi-Mandatory Preparations</h1>
    <p> Before beginning this chapter, grab Visual Studio Community (or your IDE of choice, though SadConsole is available in NuGet and is much easier to install this way). If you're using Visual Studio, you can type <b>dotnet new install SadConsole.Templates</b> into the NuGet console to install a template that will get you into the game a little faster. If you did this it should add a template you can select when making a new project. Create a "SadConsole Game (MonoGame) (Thraka)" template project, and it should auto-populate your project with files called Program, GameSettings, and RootScreen. If you run it from this point, you should get a window filled with colorful garbage with a small space cleared where it says Hello World. If you've reached this point and see this screen, you're good to move on to the next step. </p>
 
    <h1>0.5. Further Preparations</h1>
    <p>Now that you've got a working SadConsole project, go to https://github.com/nanzington/nanzington.github.io and click on the resources folder. Download and extract fonts.zip to your root project directory (resulting in a folder being added there called fonts with the four files in it), then download SadAdditions.dll and Telepathy.dll and place those in your root project directory as well. In Visual Studio, right click on Dependencies in your project sidebar on the right, and click Add Project Reference. Navigate to your project directory and select the two DLLs to add as references, allowing their code to be used in the project. SadAdditions is my helper library that contains a lot of the functions I've built up over time to do specific things the way I like with SadConsole. Telepathy is a networking library we'll be using in the next chapter to set up a client-server architecture. If you don't want to do networking, feel free to skip downloading/adding Telepathy and jump over Chapter 1a to Chapter 2.</p>

    <h1>1. Program.cs</h1>
    <p> First thing we'll be doing now that all the preparations are out of the way is immediately making a mess of Thraka's nice clean template. Go to <b>Program.cs</b> and replace the code with the following code, which will cause the project to get mad and start throwing errors. We'll fix those in a moment. For now, the code:
    <div class="code_block">
    using SadConsole.Configuration;
    using SadTutorial.UI;

    Settings.WindowTitle = "SadTutorial";

    Builder startup = new Builder()
        .SetScreenSize(GameSettings.GameWidth, GameSettings.GameHeight)
        .SetStartingScreen((host) => {
            GameSettings.SquareFont = Game.Instance.Fonts["CheepicusExtended"];
            GameSettings.UIManager = new UIManager();

            GameSettings.UIManager.Init();

            return GameSettings.UIManager;
        })
        .IsStartingScreenFocused(true)
        .ConfigureFonts("./fonts/ThinExtended.font", new[] { "./fonts/CheepicusExtended.font" })
        .AddFrameUpdateEvent(GameHost_FrameUpdate)
        ;

    Game.Create(startup);
    Game.Instance.Run();
    Game.Instance.Dispose();

    static void GameHost_FrameUpdate(object sender, GameHost e) {
        
    }
    </div>  
    <p> This code is very similar to the code that was previously there, so let's go over the changes. First we set the starting screen using a lambda expression to get some prep work done in-line, returning GameSettings.UIManager at the end. This file will work very similarly to RootScreen does currently, but in a structure I'm more familiar with and can thus expand on more easily. The next major change is that ConfigureFonts is changed to reference the fonts you should have downloaded and placed in the previous step, setting the default font to ThinExtended and adding CheepicusExtended as a secondary font.</p>

    <p>ThinExtended is a 7x12 font, while CheepicusExtended is a 12x12 font. This lets us save a decent amount of space if we only need to display text or numbers by using the thin font, while leaving the option of a square font for any time we need it (such as for a map). Finally we add a line to add a function onto the FrameUpdate, calling the function below at the end of each frame. We don't have anything we need to place there just yet, but we will in the Networking chapter and may have some other need for it in the future.</p>
    <p>Last thing to do in this step is delete the RootScreen file, as we no longer need it.</p>

    <h1>2. GameSettings.cs</h1>
    <p> This file serves as a bucket for all of our "global" variables to be placed into.  Right now we don't have many variables (just the game width and height, a reference to our square font for quick access, and our UIManager), but eventually we'll be stuffing more things into here. For now, here's the code:
    <div class="code_block">
    using SadTutorial.UI;

    public static class GameSettings {
        public const int GameWidth = 160;
        public const int GameHeight = 50;

        public static IFont SquareFont;

        public static UIManager UIManager; 
    } 
    </div>

    <h1>3. UI/UIManager.cs </h1>
    <p> As shown in the Program file we'll be using an object called UIManager as our core content container. Create a folder called UI in your root project directory, then add the following code:</p>
    <div class="code_block">
    using SadAdditions; 

    namespace SadTutorial.UI {
        public class UIManager : ScreenObject { 
            public UI_GameArea GameArea;

            public UIManager() {  }

            public override void Update(TimeSpan timeElapsed) {
                if (GameArea.Win.IsVisible) {
                    GameArea.Update();
                    GameArea.Input();
                }


                Miscellania.ClearKeys();
                base.Update(timeElapsed);
            }

            public void Init() { 
                GameArea = new(GameSettings.GameWidth, GameSettings.GameHeight);
            } 
        }
    }
    </div>
    <p> It inherits from ScreenObject, allowing it to be our core Screen holding everything, and has a single variable for now: GameArea. Our Update function is called automatically as part of it being the core Screen, and inside it we're simply checking to see if GameArea is visible (which it should almost always be), and calling Update/Input on it. <b>Miscellania.ClearKeys();</b> is the first usage of SadAdditions, and is part of the built-in hotkey system. It allows you to have buttons as hotkeys that are only called a single time per press regardless of how long you hold it down. This will make more sense as we get into UI_GameArea. Init is separate here because, as we'll see in InstantUI, one of the things InstantUI does is add itself as a child to UIManager to save as much typing as possible in UIManager.</p>
 
    <h1>4. UI/InstantUI.cs</h1>
    <p>    There are a few things nearly all of our eventual interfaces have in common. They should all have a Window (so that we can have a nice border around the content), a handful of Consoles to print things on, an Update method to draw everything to the console, and an Input method for any interface-specific input we need. So let's create a new file in the UI folder called <b>"InstantUI.cs"</b> and put the following code into it. </p>
    <div class="code_block">
    using SadConsole.Input;
    using SadConsole.UI; 

    namespace SadTutorial.UI {
        public abstract class InstantUI {
            public ScreenSurface Con;
            public ScreenSurface SquareCon;
            public ScreenSurface DoubleSquareCon;
            public Window Win;

            public InstantUI(int width, int height, string windowTitle = "") {
                Win = new(width, height);
                Win.CanDrag = true;
                Win.Position = new((GameSettings.GameWidth - width) / 2, (GameSettings.GameHeight - height) / 2);

                Con = new(width - 2, height - 2);
                Con.Position = new(1, 1);
                Win.Title = windowTitle.Align(HorizontalAlignment.Center, width - 2, (char)196);

                SquareCon = new (new CellSurface(width, height), GameSettings.SquareFont);
                SquareCon.UsePixelPositioning = true;
                SquareCon.Position = new(7, 12);

                DoubleSquareCon = new (new CellSurface(width / 2, height / 2), GameSettings.SquareFont, new Point(24, 24));
                DoubleSquareCon.UsePixelPositioning = true;
                DoubleSquareCon.Position = new Point(7, 12);

                Win.Children.Add(Con);
                Win.Children.Add(SquareCon);
                Win.Children.Add(DoubleSquareCon);
                GameSettings.UIManager.Children.Add(Win);

                Win.Show();
                Win.IsVisible = false;
            }


            public virtual void Update() {
                Con.Clear();
            }

            public virtual void Input() {
                Point mousePos = new MouseScreenObjectState(Con, GameHost.Instance.Mouse).CellPosition;
            } 
        }
    } 
    </div>
    <p>    The constructor creates the Window (Win) and the three Consoles we want to work with (Con, SquareCon, and DoubleSquareCon), adds the Consoles as Children of Win, adds Win as a Child of UIManager, and sets the positions of everything accordingly. We don't want absolutely every interface to be draggable with the mouse or hidden when the game is launched - in fact, the first interfaces we make will change these things - but we do want that to be the default. We also place the interface more or less in the center of the screen and set the Title of the window to whatever string we pass in (defaulting to no title if we don't pass one in). </p>
  
    <h1>5. UI/UI_GameArea.cs</h1>
    <p>   Time to clear up those missing reference errors from when we set up UIManager! Before we get to the helper function let's create an interface to utilize all our fancy new toys, since seeing it work is the best way to stay motivated. Create a new file in your UI folder called "<b>UI_GameArea.cs</b>" and put the following code into it: </p>
    <div class="code_block">
    using SadAdditions; 
    using SadConsole.Input; 

    namespace SadTutorial.UI {
        public class UI_GameArea : InstantUI {
            int counter = 0;
            bool switch1 = false;
            bool switch2 = false;
            bool clickSwitch = false; 

            public UI_GameArea(int width, int height) : base(width, height, "") {
                Win.IsVisible = true;
                Win.Position = new Point(0, 0);
                Win.CanDrag = false;
            }

            public override void Update() {
                Win.Clear();
                Extensions.DrawBox(Win, 0, 0, Win.Width - 2, Win.Height - 2);

                Con.Clear();
                SquareCon.Clear();
                DoubleSquareCon.Clear();

                Con.Print(0, 0, "Hello World!");
                SquareCon.Print(0, 1, "Hello World!");
                DoubleSquareCon.Print(0, 1, "Hello World!");

                if (Shorthands.KeyPressed(Keys.Space)) {
                    switch1 = !switch1;
                }

                if (Miscellania.HotkeyDown(Keys.Space)) {
                    switch2 = !switch2;
                }

                Con.Print(0, 5, "Switch 1 (Spacebar): " + switch1.ToString());
                Con.Print(0, 6, "Switch 2 (Space hotkey): " + switch2.ToString()); 
                Con.PrintClickable(0, 8, "Lambda Click: " + clickSwitch.ToString() + " [" + counter + " clicks]", () => {
                    clickSwitch = !clickSwitch;
                    counter++;
                });

                Con.PrintClickable(0, 9, "Non-lambda Click: " + clickSwitch.ToString() + " [" + counter + " clicks]", ButtonClick);
            }

            public override void Input() {

            } 

            public void ButtonClick() {
                clickSwitch = !clickSwitch;
                counter++;
            }
        }
    } 
    </div>
    <p>    This is a fairly typical implementation of our InstantUI class, though as stated previously we're using a few different parameters to fit the needs of this specific interface, which will hold the core gameplay details like the map, sidebar, and message log. Just for fun and to display some of the functions we'll be using extensively, we have some variables to play with and a few lines in the Update to interact with them. </p>

    <p> First some boilerplate: we clear the Window and all three Consoles, then draw a box around the edge of the Window to make it look nice. In addition we've got a trio of Hello Worlds to display the differences in the fonts and sizes. Below this we've got our interactables.</p>

    <p>The first two interactables demonstrate the difference between KeyPressed, which will trigger rapidly if you hold the key down, and the Hotkey system that only triggers once per press. In both cases we're just flipping the bool to the opposite of the value it holds. We display the current status of the bools with two Print statements.</p>
   
    <p>The final Print statements use an extension from SadAdditions, creating a line of text that we can click to run a function. The first one uses a lambda expression to run code in-line, while the second passes in a function from elsewhere in the file. As you can see when running the program, both function identically, and which you choose to use is situational or personal preference.</p>

    <h1>5. Conclusion</h1>
    <p>    Wow, that was a lot of work! But we've got a great base to build the rest of the project on now, and next chapter we
    can get into some actual gameplay mechanics. All the files for all chapters are stored by chapter in the <a href="https://github.com/nanzington/nanzington.github.io">GitHub repository</a>. In future chapters where we're modifying existing files, the full files will be placed at the end of the chapter for convenience.</p> 

    <p> 
    <a href="./02.html">Chapter 02: Basic Movement</a>
    <br>
    <a href="../index.html">Back to Index</a></p>
    <script src="../javascript.js"></script>
</body>
</html>